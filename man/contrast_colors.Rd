% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contrast_colors.R
\name{contrast_colors}
\alias{contrast_colors}
\alias{mutate_contrast}
\alias{plot.cc_df}
\alias{plot.cc_vec}
\alias{print.cc_df}
\alias{print.cc_vec}
\title{Choose label colors based on contrast}
\source{
\url{https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html}
}
\usage{
contrast_colors(
  pal,
  dark = "black",
  light = "white",
  n = 5,
  min_ratio = 4.5,
  verbose = TRUE,
  labels_only = TRUE,
  reverse = FALSE,
  plot = FALSE
)

mutate_contrast(
  data,
  col,
  pal,
  dark = "black",
  light = "white",
  min_ratio = 4.5,
  verbose = TRUE,
  reverse = FALSE
)

\method{plot}{cc_df}(x, ...)

\method{plot}{cc_vec}(x, ...)

\method{print}{cc_df}(x, ...)

\method{print}{cc_vec}(x, ...)
}
\arguments{
\item{pal}{String: either a vector of colors (either named R colors or hex codes), or the name of a palette from the \code{RColorBrewer}, \code{rcartocolor}, or \code{viridisLite} packages. If the name of a palette, the respective function will be called to fetch the vector of hex codes.}

\item{dark}{String giving a single valid color to use as the dark label option, either a named R color or hex code. Default: 'black'}

\item{light}{String giving a single valid color to use as the light label option, either a named R color or hex code. Default: 'white'}

\item{n}{For \code{contrast_colors}, if \code{pal} is the name of a palette, its corresponding palette will have \code{n} colors. Ignored otherwise. For \code{mutate_contrast}, this is determined by the number of levels in \code{col}. Default: 5}

\item{min_ratio}{Minimum contrast ratio, below which a pair of colors is deemed low-contrast. If \code{verbose} is true and any sets of colors fail to meet this minimum, you'll get a diagnostic message letting you know. Default: 4.5}

\item{verbose}{Logical, whether to print diagnostic info if there are issues with your contrast ratios, Default: TRUE}

\item{labels_only}{Logical, whether to return only labels, i.e. just a vector of the dark or light values, depending on which had the greatest contrast for each color in \code{pal}, or the full data frame used for calculations, including all ratios. Default: TRUE}

\item{reverse}{Boolean: if \code{TRUE}, palette will be reversed. This mostly only matters for \code{mutate_contrast}, as it determines which colors are associated with which factor levels. Default: FALSE}

\item{plot}{Logical, whether to print a \code{ggplot} swatch of tiles filled with \code{pal} and labels, using \code{plot} methods for the appropriate class. Doesn't change the return value. Default: FALSE}

\item{data}{A data frame}

\item{col}{Bare name of a column in \code{x} along which the palette will be mapped. If not already a factor, it will be coerced into one with levels in the same order in which they appear.}

\item{x}{An object returned by \code{contrast_colors}}

\item{...}{Not currently used}
}
\value{
\itemize{
\item For \code{contrast_colors}: If \code{labels_only}, a named character vector of colors, either the value of \code{dark} or \code{light}, giving the highest contrast ratio for each value of \code{pal}. This will be the same length as \code{pal} (or \code{n}, if you gave \code{pal} as the name of a palette to retrieve), and the names will be the fill colors. Otherwise, a data frame with the same number of rows as colors in \code{pal} and 6 columns of info about them, including fill and label colors (see examples).
\itemize{
\item If \code{labels_only = FALSE}, will also have the classes \code{contrast_colors} and \code{cc_df}
\item If \code{labels_only = TRUE}, will also have the classes \code{contrast_colors} and \code{cc_vec}.
}
\item For \code{mutate_contrast}, the original data frame given as \code{x}, with columns added for fill (according to \code{palette}) and label color.
}
}
\description{
This is a set of utility functions and classes for a situation that I too often gloss over: when making a chart with different fill colors (such as stacked bars with a sequential palette), it can be good to vary the label color to maintain good contrast between the background and foreground. For example, the ColorBrewer palettes often go from such a dark color to such a light color that black or dark gray labels won't be visible over the darkest bar, and white or light gray labels won't be visible over the lightest bar. This helps prepare for that by testing the contrast between a palette (presumably bar fill colors) and a light and dark option (presumably label text on those bars).

A contrast ratio is calculated by \code{colorspace::contrast_ratio} according to the WCAG algorithm, and the minimum ratio defaults to 4.5 based on their accessibility guidelines. If \code{verbose} is true and any combination of palette color and label colors fails to meet this minimum, you'll get a message letting you know. For example, using medium gray colors for both dark and light labels is likely to lead to a situation where neither the dark nor the light label color would have enough contrast over the palette.

\code{mutate_contrast} takes this a step further, working with a data frame to determine label colors from a factor column (or a column that can become a factor).

\code{plot} methods create \code{ggplot} plots as visual references of the fill and label colors. For \code{cc_df} objects, there will be two columns of fill + label combinations with their ratios and a star for the label color with the greatest contrast. For \code{cc_vec} objects, this is a simplified version giving just one column of fills and the label colors with greatest contrast, but no ratio information.
}
\examples{
# using a pre-defined palette
qual_pal <- c("#009B9E", "#DAA51B", "#C75DAB", "#898DA7", "#2A39A7")
contrast_colors(qual_pal)

# returning a data frame
contrast_colors(qual_pal, labels_only = FALSE)

# printing the plot, brewer palette
contrast_colors("YlGnBu", plot = TRUE)

# not enough contrast, carto palette
contrast_colors("Vivid", n = 7, dark = "gray40", plot = TRUE)

# Use mutate_contrast to get color information attached to your data frame
library(ggplot2)

health <- self_rated_health |>
  mutate_contrast(col = response, pal = "BuGn")

# use same palette for fill scale
# lbl_color column has colors to use, so can use identity scale
ggplot(health, aes(x = group, y = value, fill = response)) +
  geom_col(position = position_fill(reverse = TRUE)) +
  geom_text(aes(label = percent100(value), group = group, color = lbl_color), 
            position = position_fill(reverse = TRUE, vjust = 0.5)) +
  scale_fill_brewer(palette = "BuGn") +
  scale_color_identity()
  
# could actually use scale_fill_identity as well, since fill colors are in data,
# but it becomes messy when you want a legend

# now use a manual palette, and give the same set of colors to scale_fill_manual
manual_pal <- c("#005CE7", "#9C45C7", "#CC6697", "#E69259", "#F2D25C")
health_w_pal <- self_rated_health |>
  mutate_contrast(col = response, pal = manual_pal)

ggplot(health_w_pal, aes(x = group, y = value, fill = response)) +
  geom_col(position = position_fill(reverse = TRUE)) +
  geom_text(aes(label = percent100(value), group = group, color = lbl_color), 
            position = position_fill(reverse = TRUE, vjust = 0.5)) +
  scale_fill_manual(values = manual_pal) +
  scale_color_identity()
}
\seealso{
\code{\link[colorspace:contrast_ratio]{colorspace::contrast_ratio()}}, \code{\link[RColorBrewer:ColorBrewer]{RColorBrewer::brewer.pal()}}, \code{\link[rcartocolor:carto_pal]{rcartocolor::carto_pal()}}, \code{\link[viridisLite:viridis]{viridisLite::viridis()}}
}
\keyword{color}
\keyword{viz-utils}
