% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contrast_colors.R
\name{contrast_colors}
\alias{contrast_colors}
\alias{mutate_contrast}
\title{Choose label colors based on contrast}
\source{
\url{https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html}
}
\usage{
contrast_colors(
  pal,
  dark = "black",
  light = "white",
  n = 5,
  min_ratio = 4.5,
  verbose = TRUE,
  labels_only = TRUE,
  plot = FALSE
)

mutate_contrast(
  x,
  col,
  pal,
  dark = "black",
  light = "white",
  min_ratio = 4.5,
  verbose = TRUE
)
}
\arguments{
\item{pal}{String: either a vector of colors (either named R colors or hex codes), or the name of a palette from the \code{RColorBrewer}, \code{rcartocolor}, or \code{viridisLite} packages. If the name of a palette, the respective function will be called to fetch the vector of hex codes.}

\item{dark}{String giving a single valid color to use as the dark label option, either a named R color or hex code. Default: 'black'}

\item{light}{String giving a single valid color to use as the light label option, either a named R color or hex code. Default: 'white'}

\item{n}{For \code{contrast_colors}, if \code{pal} is the name of a palette, its corresponding palette will have \code{n} colors. Ignored otherwise. For \code{mutate_contrast}, this is determined by the number of levels in \code{col}. Default: 5}

\item{min_ratio}{Minimum contrast ratio, below which a pair of colors is deemed low-contrast. If \code{verbose} is true and any sets of colors fail to meet this minimum, you'll get a diagnostic message letting you know. Default: 4.5}

\item{verbose}{Logical, whether to print diagnostic info if there are issues with your contrast ratios, Default: TRUE}

\item{labels_only}{Logical, whether to return only labels, i.e. just a vector of the dark or light values, depending on which had the greatest contrast for each color in \code{pal}, or the full data frame used for calculations, including all ratios. Default: TRUE}

\item{plot}{Logical, whether to print a \code{ggplot} swatch of tiles filled with \code{pal} and labels in both the dark and light label colors. For each fill color, the label color with the highest contrast ratio will be starred, although highest might not be above the minimum required. Doesn't change the return value. Default: FALSE}

\item{x}{A data frame}

\item{col}{Bare name of a column in \code{x} along which the palette will be mapped. If not already a factor, it will be coerced into one with levels in the same order in which they appear.}
}
\value{
For \code{contrast_colors}: If \code{labels_only}, a named character vector of colors, either the value of \code{dark} or \code{light}, giving the highest contrast ratio for each value of \code{pal}. This will be the same length as \code{pal} (or \code{n}, if you gave \code{pal} as the name of a palette to retrieve), and the names will be the fill colors. Otherwise, a data frame with the same number of rows as colors in \code{pal} and 6 columns of info about them, including fill and label colors (see examples). For \code{mutate_contrast}, the original data frame given as \code{x}, with columns added for fill (according to \code{palette}) and label color.
}
\description{
This is a pair of utility functions for a situation that I too often gloss over: when making a chart with different fill colors (such as stacked bars with a sequential palette), it can be good to vary the label color to maintain good contrast between the background and foreground. For example, the ColorBrewer palettes often go from such a dark color to such a light color that black or dark gray labels won't be visible over the darkest bar, and white or light gray labels won't be visible over the lightest bar. This helps prepare for that by testing the contrast between a palette (presumably bar fill colors) and a light and dark option (presumably label text on those bars).

A contrast ratio is calculated by \code{colorspace::contrast_ratio} according to the WCAG algorithm, and the minimum ratio defaults to 4.5 based on their accessibility guidelines. If \code{verbose} is true and any combination of palette color and label colors fails to meet this minimum, you'll get a message letting you know. For example, using medium gray colors for both dark and light labels is likely to lead to a situation where neither the dark nor the light label color would have enough contrast over the palette.

\code{mutate_contrast} takes this a step further, working with a data frame to determine label colors from a factor column (or a column that can become a factor).
}
\examples{
# using a pre-defined palette
qual_pal <- c("#009B9E", "#DAA51B", "#C75DAB", "#898DA7", "#2A39A7")
contrast_colors(qual_pal)

# returning a data frame
contrast_colors(qual_pal, labels_only = FALSE)

# printing the plot, brewer palette
contrast_colors("YlGnBu", plot = TRUE)

# not enough contrast, carto palette
contrast_colors("Vivid", n = 7, dark = "gray40", plot = TRUE)

library(ggplot2)
# For a very small data frame, it's possible to assign label colors with 
# `contrast_colors` directly back into the data frame, then use
# `scale_color_identity`. 
food <- dplyr::filter(fin_insecurity, question == "food_insecurity", 
                      category \%in\% c("Greater New Haven", "Age"))
food$lbl_color <- contrast_colors(qual_pal)
ggplot(food, aes(x = group, y = value, fill = group)) +
  geom_col() +
  geom_text(aes(label = percent100(value), color = lbl_color), 
            vjust = 1, nudge_y = -0.01, fontface = "bold") +
  scale_fill_manual(values = qual_pal) +
  scale_color_identity()

# For a larger data frame, use `mutate_contrast` to get the contrast info
# joined back to your data frame. Since this includes the fill colors, you
# can use `scale_fill_identity`, but this requires putting your legend back in.
health <- dplyr::filter(self_rated_health, category == "Age") |>
  mutate_contrast(col = response, pal = "viridis", dark = "gray10")
head(health)

ggplot(health, aes(x = group, y = value, fill = fill, group = group)) +
  geom_col(position = position_fill()) +
  geom_text(aes(label = percent100(value), color = lbl_color), 
            position = position_fill(vjust = 0.5), fontface = "bold") +
  scale_color_identity() +
  scale_fill_identity(guide = guide_legend(), labels = levels(health$response))

# Alternatively, pull out the palette as a named list and pass that to
# `scale_fill_manual`.
resp_pal <- health |>
  dplyr::distinct(response, fill) |>
  tibble::deframe()

ggplot(health, aes(x = group, y = value, fill = response, group = group)) +
  geom_col(position = position_fill()) +
  geom_text(aes(label = percent100(value), color = lbl_color), 
            position = position_fill(vjust = 0.5), fontface = "bold") +
  scale_color_identity() +
  scale_fill_manual(values = resp_pal)
}
\seealso{
\code{\link[colorspace:contrast_ratio]{colorspace::contrast_ratio()}}, \code{\link[RColorBrewer:ColorBrewer]{RColorBrewer::brewer.pal()}}, \code{\link[rcartocolor:carto_pal]{rcartocolor::carto_pal()}}, \code{\link[viridisLite:viridis]{viridisLite::viridis()}}
}
